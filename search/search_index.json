{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ESP32 PC Fan Controller","text":"<p>An advanced, highly configurable PC fan controller based on the ESP32 microcontroller, featuring LCD menu control, optional WiFi with a web interface, and a serial debug console.</p> <p>This project provides a robust solution for managing PC cooling fans with precision, offering both automated temperature-based regulation and manual control. It's designed for hobbyists and enthusiasts looking for a customizable alternative to standard motherboard fan controls.</p>"},{"location":"#documentation-chapters","title":"Documentation Chapters","text":"<p>Please navigate through the documentation using the links below:</p> <ol> <li>Introduction </li> <li>Project Overview  </li> <li>Why This Project?  </li> <li>Key Goals  </li> <li>Features Summary  </li> <li>Hardware </li> <li>Required Components  </li> <li>Recommended Hardware Stack &amp; Component Details  </li> <li>Wiring Considerations &amp; Block Diagram  </li> <li>Software </li> <li>Development Environment  </li> <li>Libraries Required &amp; platformio.ini  </li> <li>Firmware Architecture (Dual-Core, Tasks)  </li> <li>Code Structure (Key Files and Their Roles)  </li> <li>Setup and Installation </li> <li>Hardware Assembly Tips  </li> <li>Software Setup (PlatformIO)  </li> <li>Uploading Firmware and Filesystem Data  </li> <li>Usage Guide </li> <li>First Boot and Initial State  </li> <li>LCD Menu Navigation &amp; Options  </li> <li>Serial Command Interface (Debug Mode)  </li> <li>Web Interface (If WiFi Enabled)  </li> <li>Technical Details &amp; Protocols </li> <li>PWM Fan Control  </li> <li>I2C Communication  </li> <li>Fan Tachometer (RPM Sensing)  </li> <li>WiFi and Networking (Async Web Server, WebSockets)  </li> <li>SPIFFS Filesystem Usage  </li> <li>NVS (Non-Volatile Storage) for Persistence  </li> <li>Conditional Debug Mode &amp; LED Indicator  </li> <li>Dual-Core Operation (FreeRTOS Tasks)  </li> <li>Troubleshooting </li> <li>Common Issues and Solutions  </li> <li>Future Enhancements </li> <li>Potential improvements and new features.</li> </ol> <p>This documentation is for the ESP32 PC Fan Controller project. Please refer to the specific chapter files for detailed information.</p>"},{"location":"01-introduction/","title":"Chapter 1: Introduction","text":""},{"location":"01-introduction/#11-project-overview","title":"1.1. Project Overview","text":"<p>This project details the creation of an advanced and highly customizable PC fan controller utilizing the ESP32 microcontroller. It aims to offer superior control, monitoring, and configuration options compared to standard motherboard fan control systems or basic commercial fan hubs. The controller allows for both automated temperature-based fan regulation and precise manual adjustments, accessible through multiple interfaces: an onboard LCD menu with physical buttons, a web interface (when WiFi is active), a conditional serial command interface, MQTT with Home Assistant Discovery for seamless integration into smart home ecosystems, and Over-the-Air (OTA) firmware updates.</p> <p>The core philosophy is to provide a flexible, open, and powerful tool for PC enthusiasts who want granular control over their system's cooling and acoustics, with the ability to easily update the device firmware remotely.</p>"},{"location":"01-introduction/#12-why-this-project","title":"1.2. Why This Project?","text":"<p>Many PC users, especially those building custom systems or pushing their hardware, find stock fan control solutions lacking. Motherboard BIOS settings can be limited, and software solutions can sometimes be resource-intensive or platform-dependent. Commercial fan controllers exist, but they may not offer the desired level of customization, open-source flexibility, or specific features an enthusiast might want.</p> <p>This ESP32-based project addresses these points by:</p> <ul> <li>Offering Deep Customization: Users can define precise fan curves, control multiple aspects of the system, and even extend the functionality due to its open nature.  </li> <li>Providing Multiple Control Interfaces: Catering to different user preferences, whether it's direct physical interaction via an LCD, remote control via a web browser, technical interaction via a serial console, integration with home automation via MQTT with auto-discovery, or initiating firmware updates through these interfaces. </li> <li>Leveraging Modern Microcontroller Capabilities: The ESP32's dual-core processor, built-in WiFi, and ample GPIOs make it an ideal platform for such a feature-rich device.  </li> <li>Being an Educational Platform: Building this project offers insights into embedded systems, PWM control, sensor integration, web servers on microcontrollers, real-time operating system (RTOS) concepts, IoT communication protocols like MQTT (including service discovery), and implementing secure remote firmware updates. </li> <li>Facilitating Easy Updates: The OTA update feature allows for seamless deployment of new features and bug fixes without requiring physical access to the device.</li> </ul>"},{"location":"01-introduction/#13-key-goals","title":"1.3. Key Goals","text":"<p>The primary objectives of this project are:</p> <ul> <li>Precision: Implement fine-grained PWM control for 4-pin PC fans, allowing for smooth and accurate speed adjustments from 0% to 100%.  </li> <li>Automation: Enable automatic fan speed adjustment based on (optional) temperature sensor readings via a user-configurable multi-point fan curve.  </li> <li>Manual Override: Provide users the ability to manually set and hold specific fan speeds, irrespective of temperature.  </li> <li>Real-time Monitoring: Display critical system parameters including current temperature (if sensor present), current fan speed (as a percentage), and actual fan RPM (via tachometer feedback).  </li> <li>Multiple Interfaces: </li> <li>LCD &amp; Buttons: An intuitive onboard menu system for standalone configuration, status display, and initiating OTA updates. </li> <li>Web UI: A responsive web interface for remote monitoring, configuration, and initiating OTA updates. </li> <li>Serial Console: A command-line interface for debugging, advanced configuration, diagnostics, and initiating OTA updates. </li> <li>MQTT: Integration for publishing status and receiving commands from home automation systems, featuring Home Assistant MQTT Discovery for automatic entity creation.  </li> <li>Remote Firmware Updates (OTA): </li> <li>Implement OTA updates via the ESPAsyncWebServer (ElegantOTA) for manual file uploads. </li> <li>Implement a feature to check for and download firmware and SPIFFS updates directly from GitHub releases. This includes version checking against the current firmware.  </li> <li>Flexibility &amp; Modularity: </li> <li>Make WiFi connectivity an optional feature, configurable by the user.  </li> <li>Make the temperature sensor an optional component, with graceful fallback behavior if not present.  </li> <li>Make MQTT connectivity and Home Assistant Discovery optional features, configurable by the user.  </li> <li>Persistence: Store all user settings (WiFi credentials, MQTT configuration, MQTT Discovery settings, fan curve, operational states) in the ESP32's non-volatile memory (NVS) to ensure they persist across reboots and power cycles.  </li> <li>Efficiency &amp; Responsiveness: Leverage the ESP32's dual-core architecture with FreeRTOS to separate network handling from the main control loop, ensuring responsive performance.  </li> <li>Debuggability: Include comprehensive serial logging (conditionally enabled) and an onboard LED indicator for debug mode status.  </li> <li>Accessibility &amp; Affordability: Design the system using readily available, relatively inexpensive components without significantly compromising on quality, reliability, or the \"cool factor\" of the final product.</li> </ul>"},{"location":"01-introduction/#14-features-summary","title":"1.4. Features Summary","text":"<ul> <li>Controls one or more 4-pin PWM PC fans (current software focuses on one, easily expandable).  </li> <li>Optional BMP280 temperature sensor for precise thermal readings.  </li> <li>Automated fan speed control based on a user-configurable multi-point temperature curve (editable via Web UI, MQTT, or Serial).  </li> <li>Manual fan speed control (0-100%) selectable via LCD, Web UI, Serial, or MQTT.  </li> <li>Real-time fan RPM monitoring via tachometer input, displayed on LCD, Web UI, and published via MQTT.  </li> <li>16x2 I2C LCD display for live status and a comprehensive menu-driven configuration system.  </li> <li>Physical button interface (Menu, Up, Down, Select, Back) for intuitive LCD menu navigation.  </li> <li>Optional WiFi connectivity:  </li> <li>Web interface served from SPIFFS for remote monitoring and configuration (including MQTT and Discovery settings).  </li> <li>Real-time data synchronization using WebSockets.  </li> <li>Over-the-Air (OTA) Firmware Updates: </li> <li>ElegantOTA Integration: Provides a web endpoint (/update) for manually uploading firmware.bin or spiffs.bin files.  </li> <li>GitHub Release Updater: Feature to check the project's GitHub repository (dnviti/SmartWifiFanController) for the latest release.  <ul> <li>Compares the latest release version with the current running firmware version.  </li> <li>If a newer version is found, allows the user to initiate the download and update of both firmware and SPIFFS image directly from the GitHub release assets.  </li> <li>Can be triggered via LCD Menu, Web UI, or Serial Command.  </li> <li>Uses a Root CA certificate loaded from SPIFFS (/github_root_ca.pem) for secure HTTPS connections to GitHub.  </li> </ul> </li> <li>Optional MQTT Connectivity with Home Assistant Discovery:  </li> <li>Publishes device status (temperature, fan speed, RPM, mode, settings states, etc.) to configurable topics.  </li> <li>Subscribes to command topics for remote control (mode, manual speed, fan curve, select configurations).  </li> <li>Automatically creates entities in Home Assistant for fan control, sensors (temp, RPM, diagnostics), and configuration (fan curve, discovery settings, reboot).  </li> <li>Supports MQTT Last Will and Testament (LWT) for availability status.  </li> <li>Full WiFi, MQTT, and MQTT Discovery configuration manageable via all interfaces.  </li> <li>Persistent storage of all critical settings in NVS.  </li> <li>Dual-core operation for enhanced performance:  </li> <li>Core 0: Dedicated to network tasks (WiFi, Web Server, WebSockets, MQTT Client, ElegantOTA handler).  </li> <li>Core 1: Handles main application logic (sensor polling, LCD updates, button inputs, fan control algorithms, serial commands, GitHub OTA check logic).  </li> <li>Conditional Serial Debug Interface:  </li> <li>Activated by a physical GPIO pin (DEBUG_ENABLE_PIN).  </li> <li>Provides extensive runtime logs and a command-line interface for advanced control.  </li> <li>An onboard LED visually indicates if debug mode is active.  </li> <li>Web UI features a loading animation for an improved initial page load experience.  </li> <li>Modular C++ code structure, separating concerns into logical files for better maintainability and scalability.  </li> <li>Firmware version tracking.  </li> <li>Dynamic Hostname: Sets hostname to fancontrol-[macaddress] for easier network identification.  </li> <li>Automated GitHub Release Pipeline: Builds firmware and SPIFFS (including the latest CA certificate) upon pushes to release/v* branches, creating versioned and \"latest\" GitHub releases.</li> </ul> <p>Next Chapter: Hardware</p>"},{"location":"02-hardware/","title":"Chapter 2: Hardware","text":"<p>This chapter details the necessary and recommended hardware components for building the ESP32 PC Fan Controller, along with high-level wiring considerations.</p>"},{"location":"02-hardware/#21-required-components","title":"2.1. Required Components","text":"<p>The following components are essential for a basic functional version of the project:</p> <ul> <li>Microcontroller:<ul> <li>An ESP32-based development board. Common choices include generic ESP32 DevKits (often with the ESP32-WROOM-32 module) or specific boards like the uPesy ESP32 Wroom DevKit. Ensure it has sufficient GPIO pins for all planned peripherals.</li> </ul> </li> <li>Display:<ul> <li>16x2 I2C Character LCD Display: Must have an I2C backpack module (commonly using the PCF8574 I/O expander chip) to simplify wiring. The I2C address is typically <code>0x27</code> or <code>0x3F</code>.</li> </ul> </li> <li>Navigation Inputs:<ul> <li>5x Tactile Push Buttons: For Menu, Up, Down, Select, and Back functions.</li> </ul> </li> <li>PC Fan(s):<ul> <li>At least one standard 4-pin PWM PC cooling fan (12V). The project is designed around 4-pin fans for PWM speed control.</li> </ul> </li> <li>Power Supply Components:<ul> <li>12V DC Source: This will power the fans directly and be stepped down for the ESP32. Options:<ul> <li>PC Power Supply Unit (PSU): Using a Molex or SATA power connector (requires appropriate adapter/wiring).</li> <li>Motherboard Fan Header: Can supply 12V, but ensure the total current draw of your controller and connected fan(s) does not exceed the header's limit (typically 1A, but check motherboard specs).</li> <li>External 12V DC Power Adapter: If building a standalone unit.</li> </ul> </li> <li>12V to 5V Buck Converter Module: Essential for stepping down the 12V input to a stable 5V suitable for the ESP32's VIN pin. Modules based on the MP1584EN, LM2596 (use with caution, quality varies), or similar switching regulators are common. Ensure its current rating is sufficient for the ESP32 and any other 5V peripherals.</li> </ul> </li> <li>Resistors:<ul> <li>Pull-up Resistors for I2C (if not on modules): Typically 2x 4.7k\u03a9 or 10k\u03a9 resistors (one for SDA, one for SCL, connected to 3.3V). Many sensor and display modules include these.</li> <li>Pull-up Resistor for Fan Tachometer: 1x 10k\u03a9 resistor connected between the fan's tachometer signal line and the ESP32's 3.3V supply.</li> <li>(Optional for Buttons): If not using the ESP32's internal <code>INPUT_PULLUP</code> mode, you'll need pull-up or pull-down resistors (e.g., 5x 10k\u03a9) for each button.</li> </ul> </li> <li>Logic Level Shifter (for Fan PWM - Highly Recommended):<ul> <li>To convert the ESP32's 3.3V logic level PWM signal to the 5V TTL signal expected by most PC fans. This ensures reliable fan speed control across a wider range of fans. A simple N-channel MOSFET (like BSS138) with two resistors (e.g., 10k\u03a9) per fan channel can be used.</li> </ul> </li> <li>Jumper/Switch (for Debug Mode):<ul> <li>A simple SPST switch or a 2-pin header with a jumper to connect the <code>DEBUG_ENABLE_PIN</code> to 3.3V (to enable debug) or leave it pulled low (to disable).</li> </ul> </li> <li>Connectors:<ul> <li>At least one 4-pin male PC fan header for connecting the fan to your controller.</li> <li>Appropriate connectors for your 12V power input.</li> </ul> </li> <li>Prototyping Supplies:<ul> <li>Breadboard(s).</li> <li>Jumper Wires (male-male, male-female).</li> </ul> </li> </ul>"},{"location":"02-hardware/#22-recommended-hardware-stack-component-details","title":"2.2. Recommended Hardware Stack &amp; Component Details","text":"<p>For a higher quality, more robust, and aesthetically pleasing build:</p> <ul> <li>Microcontroller: ESP32-WROOM-32E or ESP32-WROOM-32UE.<ul> <li>Reasoning: These are current-generation modules with good performance, reliability, and community support. The \"UE\" variant offers a U.FL connector for an external antenna, which can be crucial if the controller is housed in a metal PC case that might attenuate the onboard antenna's WiFi signal.</li> </ul> </li> <li>Temperature Sensor (Optional): BMP280 (I2C).<ul> <li>Reasoning: Provides accurate temperature readings, is digitally interfaced (I2C), low power, and widely available at a low cost. The pressure data it also provides is not used by this project but doesn't hurt.</li> </ul> </li> <li>Display: 0.96\" or 1.3\" I2C OLED Display (SSD1306 or SH1106 controller).<ul> <li>Reasoning: Offers significantly better readability, contrast, and viewing angles than standard 16x2 character LCDs. They can display more information graphically and contribute to a more \"premium\" feel. Note: The current firmware uses the <code>LiquidCrystal_I2C</code> library. Switching to an OLED would require using a different display library (e.g., Adafruit SSD1306 or U8g2) and rewriting the display-related functions.</li> </ul> </li> <li>Power Regulation: Integrated Buck Converter on Custom PCB (using ICs like MP2307, MP1584EN, TPS54331) or a high-quality MP1584EN-based module.<ul> <li>Reasoning: Stable and clean power is vital for the ESP32 and sensor accuracy. Integrating the buck converter onto a custom PCB allows for better layout, component selection, and a more compact design. If using a module, avoid the cheapest unbranded LM2596 modules as their performance and ripple can be poor.</li> </ul> </li> <li>Fan PWM Logic Level Shifter: MOSFET-based (BSS138) or dedicated IC (e.g., 74AHCT125, 74LVC1T45).<ul> <li>Reasoning: Ensures the fan receives a proper 5V PWM signal, maximizing compatibility and control range. A BSS138 with two 10k\u03a9 pull-up resistors (one to 3.3V on the ESP32 side, one to 5V on the fan side) is a common and effective single-channel solution.</li> </ul> </li> <li>Buttons: Good quality, PCB-mounted tactile switches.<ul> <li>Reasoning: Provide reliable input and good tactile feedback. When paired with a custom enclosure and button caps, they contribute to a professional product feel.</li> </ul> </li> <li>Final Build: Custom PCB and a well-designed Enclosure.<ul> <li>Reasoning: A PCB is non-negotiable for a reliable and presentable final product. An enclosure (e.g., 3D printed with PETG/ASA for temperature resistance, or a custom-machined/lasercut box) protects the electronics and greatly enhances the overall aesthetic and perceived value. Consider ventilation in the enclosure design.</li> </ul> </li> </ul>"},{"location":"02-hardware/#23-wiring-considerations-high-level","title":"2.3. Wiring Considerations (High-Level)","text":"<p>(A detailed Fritzing diagram or schematic would be ideal here in a full project repository, but for text-based documentation, a description is provided.)</p> <ul> <li>ESP32 Power:<ul> <li>12V DC input connects to the VIN of your 12V-to-5V buck converter.</li> <li>GND of the 12V input connects to the GND of the buck converter.</li> <li>5V output from the buck converter connects to the ESP32's VIN (or 5V) pin.</li> <li>GND output from the buck converter connects to an ESP32 GND pin.</li> </ul> </li> <li>Fan(s):<ul> <li>GND (Pin 1): Connect to the common ground of your circuit (shared with ESP32 GND).</li> <li>+12V (Pin 2): Connect directly to your 12V power source (the same source feeding the buck converter).</li> <li>Tachometer/Sense (Pin 3): Connect to the designated ESP32 GPIO (<code>FAN_TACH_PIN_ACTUAL</code>). A 10k\u03a9 pull-up resistor should be connected between this GPIO pin and the ESP32's 3.3V line.</li> <li>Control/PWM (Pin 4): Connect to the output of your 3.3V-to-5V logic level shifter. The input of the logic level shifter connects to the ESP32's <code>FAN_PWM_PIN</code> GPIO.</li> </ul> </li> <li>I2C Devices (LCD &amp; BMP280):<ul> <li>SDA: Connect ESP32's SDA pin (typically GPIO21) to the SDA pins of both the LCD and BMP280.</li> <li>SCL: Connect ESP32's SCL pin (typically GPIO22) to the SCL pins of both the LCD and BMP280.</li> <li>VCC: LCD VCC to 5V (from buck converter). BMP280 VCC to 3.3V (from ESP32's 3V3 pin).</li> <li>GND: Connect to common ground.</li> <li>Pull-up Resistors: If not already present on the modules, add 4.7k\u03a9-10k\u03a9 pull-up resistors from SDA to 3.3V and SCL to 3.3V.</li> </ul> </li> <li>Buttons:<ul> <li>Connect one terminal of each button to a dedicated ESP32 GPIO pin (e.g., <code>BTN_MENU_PIN</code>, <code>BTN_UP_PIN</code>, etc.).</li> <li>Connect the other terminal of each button to GND.</li> <li>The firmware will use the ESP32's internal pull-up resistors (<code>INPUT_PULLUP</code>).</li> </ul> </li> <li>Debug Enable Pin:<ul> <li>Connect <code>DEBUG_ENABLE_PIN</code> to one terminal of a switch or jumper header.</li> <li>Connect the other terminal of the switch/jumper header to 3.3V.</li> <li>The pin is configured with <code>INPUT_PULLDOWN</code> in the firmware, so leaving it open or connected to GND will disable debug mode. Connecting it to 3.3V will enable debug mode.</li> </ul> </li> <li>Debug LED:<ul> <li>Connect the anode (longer leg) of an LED to <code>LED_DEBUG_PIN</code> (GPIO2).</li> <li>Connect the cathode (shorter leg) of the LED to a current-limiting resistor (e.g., 220\u03a9 - 330\u03a9).</li> <li>Connect the other end of the resistor to GND.</li> </ul> </li> </ul> <p>Simplified Block Diagram Concept:</p> <pre><code>                                 +-----------+\n                                 |   12V DC  |\n                                 |   Input   |\n                                 +-----+-----+\n                                       | (12V)\n                                       |\n                             +---------v-------+     +--------+\n                             |  12V to 5V Buck |----&gt;| PC Fan | (12V Power)\n                             |   Converter     |     | (12V)  |\n                             +---------+-------+     +----+---+\n                                       | (5V)             | (Tach)\n                                       |                  |\n+--------------------------------------v------------------v------------------------------------------+\n|                                                                                                     |\n|  +-----------+   (I2C)    +---------+      (I2C)     +-----------------+                            |\n|  |   LCD     |&lt;----------&gt;|  ESP32  |&lt;--------------&gt;| BMP280 Sensor   |                            |\n|  | (5V/3.3V) |            | (3.3V)  |&lt;------(3.3V)---| (Optional)      |                            |\n|  +-----------+            +----+----+                +-----------------+                            |\n|                              | | | |                                                                |\n|  +-----------+  (GPIOs)      | | | `----(3.3V PWM)---&gt;[Logic Shifter]---&gt;(5V PWM)--+--------------+ |\n|  | Buttons   |&lt;--------------' | `----(GPIO for Tach)--&gt;(Pulled up to 3.3V)&lt;-------| Fan Tach Pin | |\n|  | (5x)      |                 |                                                   +--------------+ |\n|  +-----------+                 `----(GPIO for Debug LED)-------------------------&gt;[Debug LED]       |\n|                                                                                                     |\n|  +---------------------+  (GPIO)                                                                    |\n|  | Debug Enable Switch |&lt;---------------------------------------------------------------------------+\n|  +---------------------+\n+-----------------------------------------------------------------------------------------------------+\n</code></pre> <p>This detailed hardware setup provides a solid foundation for a reliable and feature-rich fan controller. Always double-check your specific ESP32 board's pinout diagram.</p> <p>Previous Chapter: Introduction | Next Chapter: Software</p>"},{"location":"03-software/","title":"Chapter 3: Software","text":"<p>This chapter details the software aspects of the ESP32 PC Fan Controller, including the development environment, required libraries, firmware architecture, and the structure of the codebase.</p>"},{"location":"03-software/#31-development-environment","title":"3.1. Development Environment","text":"<ul> <li>Recommended IDE: PlatformIO IDE within Visual Studio Code </li> <li>Why: PlatformIO offers superior library management (via platformio.ini), robust build system configuration, easy switching between boards/frameworks, and excellent integration with VS Code for features like IntelliSense, debugging, and version control.  </li> <li>Alternative: Arduino IDE with ESP32 Core </li> <li>Ensure the latest ESP32 core is installed via the Boards Manager.  </li> <li>Library management is done manually through the Arduino Library Manager.</li> </ul>"},{"location":"03-software/#32-libraries-required","title":"3.2. Libraries Required","text":"<p>The following libraries are crucial for the project's functionality. When using PlatformIO, these are specified in the platformio.ini file for automatic management.</p> <ul> <li>Core ESP32 Libraries (Bundled with ESP32 Arduino Core): </li> <li>WiFi.h: For WiFi connectivity (station mode).  </li> <li>Wire.h: For I2C communication with the LCD and BMP280 sensor.  </li> <li>Preferences.h: For accessing Non-Volatile Storage (NVS) to save settings.  </li> <li>SPIFFS.h: For accessing the SPI Flash File System to serve web files.  </li> <li>Arduino.h: (Often implicitly included, but good practice to ensure core Arduino functions are available).  </li> <li>Asynchronous Web Server &amp; TCP: </li> <li>AsyncTCP.h: (e.g., esp32async/AsyncTCP or me-no-dev/AsyncTCP for ESP32)  <ul> <li>Provides the underlying asynchronous TCP layer required by ESPAsyncWebServer.  </li> </ul> </li> <li>ESPAsyncWebServer.h: (e.g., esp32async/ESPAsyncWebServer or me-no-dev/ESP Async WebServer)  <ul> <li>A lightweight and efficient asynchronous HTTP and WebSocket server library. Essential for handling web requests and WebSocket connections without blocking other operations.  </li> </ul> </li> <li>WebSockets: </li> <li>WebSocketsServer.h: (e.g., links2004/WebSockets by Markus Sattler)  <ul> <li>Used to implement the WebSocket server for real-time bidirectional communication with the web UI.  </li> </ul> </li> <li>Sensors: </li> <li>Adafruit_BMP280.h: (e.g., adafruit/Adafruit BMP280 Library)  <ul> <li>Driver for the BMP280 temperature and pressure sensor.  </li> </ul> </li> <li>Adafruit_Sensor.h: (e.g., adafruit/Adafruit Unified Sensor)  <ul> <li>A unified sensor abstraction layer, a dependency for many Adafruit sensor libraries including the BMP280.  </li> </ul> </li> <li>Display: </li> <li>LiquidCrystal_I2C.h: (e.g., marcoschwartz/LiquidCrystal_I2C or \"LiquidCrystal I2C\" by Frank de Brabander - ensure ESP32 compatibility).  <ul> <li>Controls I2C-based character LCDs.  </li> </ul> </li> <li>JSON Handling: </li> <li>ArduinoJson.h: (e.g., bblanchon/ArduinoJson - version 7.x is recommended and used in the current codebase).  <ul> <li>Efficiently parses and generates JSON data for WebSocket communication.</li> </ul> </li> </ul> <p>Example platformio.ini lib_deps section:</p> <pre><code>lib_deps = \n    ; Async Web Server and TCP\n    ottowinter/ESPAsyncWebServer-esphome @ ^3.3.0     ; A well-maintained fork, or use me-no-dev/ESP Async WebServer\n    esphome/AsyncTCP-esphome @ ^2.1.4                 ; Dependency for the ESPAsyncWebServer fork above, or use me-no-dev/AsyncTCP\n\n    ; WebSockets\n    links2004/WebSockets @ ^2.6.1                     ; By Markus Sattler, very common\n\n    ; Temperature Sensor\n    adafruit/Adafruit BMP280 Library @ ^2.6.8\n    adafruit/Adafruit Unified Sensor @ ^1.1.15        ; Dependency for BMP280\n\n    ; I2C LCD\n    iakop/LiquidCrystal_I2C_ESP32 @ ^1.1.6           ; By Frank de Brabander\n\n    ; JSON Handling\n    bblanchon/ArduinoJson @ ^7.4.1\n</code></pre> <p>Note: Specific versions (@^x.y.z) can be added for better build reproducibility.</p>"},{"location":"03-software/#33-firmware-architecture","title":"3.3. Firmware Architecture","text":"<p>The firmware is designed around the ESP32's dual-core capabilities using FreeRTOS tasks to ensure responsiveness and efficient handling of concurrent operations.</p> <ul> <li>Dual-Core Task Allocation: </li> <li>Core 0 (Protocol Core - networkTask): <ul> <li>Responsibilities: Exclusively handles network-related operations.  </li> <li>Manages WiFi connection lifecycle (connecting, monitoring status).  </li> <li>Runs the ESPAsyncWebServer to serve static web files (HTML, CSS, JS) from SPIFFS.  </li> <li>Manages the WebSocketsServer for real-time communication with web clients.  </li> <li>Processes incoming WebSocket messages and sends outgoing data broadcasts.  </li> <li>This task is only created and run if WiFi is enabled in the configuration.  </li> </ul> </li> <li>Core 1 (Application Core - mainAppTask): <ul> <li>Responsibilities: Handles all main device logic and user interaction.  </li> <li>Reads data from the BMP280 temperature sensor (if tempSensorFound).  </li> <li>Calculates fan RPM using the tachometer input via an ISR.  </li> <li>Manages the LCD, including updating the normal status display and rendering all menu screens.  </li> <li>Processing inputs from the physical buttons for LCD menu navigation.  </li> <li>Executing the core fan control algorithms (Auto mode based on temperature curve, Manual mode).  </li> <li>Handling commands received via the Serial interface (if serialDebugEnabled).  </li> <li>Updating shared state variables that are then read by networkTask for broadcasting.  </li> </ul> </li> <li>Interrupt Service Routine (ISR): </li> <li>countPulse(): Attached to the FAN_TACH_PIN_ACTUAL. This ISR increments a volatile pulse counter on each falling edge of the fan's tachometer signal. Being an ISR, it executes with high priority and minimal latency, ensuring accurate pulse counting even while other tasks are running.  </li> <li>Shared Data and Inter-Task Communication: </li> <li>volatile Variables: Global variables shared between tasks (e.g., currentTemperature, fanRpm, isAutoMode, fanSpeedPercentage) are declared volatile to prevent compiler optimizations that might lead to stale data reads.  </li> <li>needsImmediateBroadcast Flag: A volatile bool flag used by mainAppTask to signal networkTask that critical state has changed and an immediate WebSocket broadcast is required, rather than waiting for the next periodic broadcast.  </li> <li>Fan Curve Arrays: tempPoints and pwmPercentagePoints are global. Updates from the web UI (via networkTask) or serial commands (via mainAppTask) modify these directly. NVS saving acts as the commit. For very high-frequency concurrent access, a mutex would be advisable, but for user-driven changes, this is generally acceptable.  </li> <li>State-Driven Logic: </li> <li>The system operates based on several key state flags like isAutoMode, isInMenuMode, isWiFiEnabled, and tempSensorFound. The behavior of tasks and functions adapts based on these states.</li> </ul> <p>Conceptual Task Interaction:</p> <pre><code>Core 0 (Network)                     Core 1 (Application)  \n+------------------+                    +-----------------------+  \n|  networkTask     |&lt;-------------------| mainAppTask           |  \n| - WiFi Connect   | (needsBroadcast)   | - Read Sensors (Temp) |  \n| - Web Server     |                    | - Read Tachometer     |  \n| - WebSocket Srv  |---(Web Cmds)------&gt;|   (via ISR)           |  \n|   - Listen       |&lt;--(Shared State)---| - Update LCD          |  \n|   - Broadcast    |                    | - Handle Buttons      |  \n+------------------+                    | - Handle Serial Cmds  |  \n                                        | - Fan Control Logic   |  \n                                        +-----------------------+  \n                                                  | (ISR)  \n                                        +-----------------------+  \n                                        | countPulse (Tach)     |  \n                                        +-----------------------+\n</code></pre>"},{"location":"03-software/#34-code-structure-key-files-in-src","title":"3.4. Code Structure (Key Files in src/)","text":"<p>The project is organized into several header (.h) and source (.cpp) files to promote modularity and maintainability:</p> <ul> <li>main.cpp: </li> <li>Includes all other custom headers.  </li> <li>Contains the definitions for all global variables declared extern in config.h.  </li> <li>The main setup() function: Initializes hardware, loads configurations from NVS, and creates the FreeRTOS tasks.  </li> <li>The main loop() function: Kept minimal, as primary operations are handled by FreeRTOS tasks.  </li> <li>config.h: </li> <li>Central header file included by most other files.  </li> <li>Defines constants (pin numbers, PWM parameters, array sizes like MAX_CURVE_POINTS).  </li> <li>Contains extern declarations for all global variables and objects (e.g., lcd, server, bmp, state flags). This allows other files to access these globals after they are defined in main.cpp.  </li> <li>Defines enums (e.g., MenuScreen).  </li> <li>nvs_handler.h / nvs_handler.cpp: </li> <li>Encapsulates all functions related to Non-Volatile Storage (NVS) using the Preferences library.  </li> <li>saveWiFiConfig(), loadWiFiConfig()  </li> <li>saveFanCurveToNVS(), loadFanCurveFromNVS()  </li> <li>fan_control.h / fan_control.cpp: </li> <li>Contains logic related to fan operation.  </li> <li>setDefaultFanCurve(): Initializes the default fan curve.  </li> <li>calculateAutoFanPWMPercentage(): Calculates the target fan speed based on temperature and the current curve.  </li> <li>setFanSpeed(): Applies a given percentage to the fan via PWM (using ESP32 LEDC functions).  </li> <li>IRAM_ATTR countPulse(): The Interrupt Service Routine for counting fan tachometer pulses.  </li> <li>display_handler.h / display_handler.cpp: </li> <li>Manages all output to the I2C LCD.  </li> <li>updateLCD_NormalMode(): Renders the standard status display.  </li> <li>displayMenu(): Main function to call specific menu rendering functions.  </li> <li>displayMainMenu(), displayWiFiSettingsMenu(), etc.: Functions to render each specific screen of the LCD menu system.  </li> <li>input_handler.h / input_handler.cpp: </li> <li>Handles user inputs.  </li> <li>handleMenuInput(): Processes physical button presses, debounces them, and updates menu states or triggers actions.  </li> <li>handleSerialCommands(): Parses and executes commands received via the Serial interface when debug mode is active.  </li> <li>Includes helper functions called by menu/serial actions like performWiFiScan(), attemptWiFiConnection(), disconnectWiFi().  </li> <li>network_handler.h / network_handler.cpp: </li> <li>Manages all web-related functionalities.  </li> <li>setupWebServerRoutes(): Configures the AsyncWebServer to serve static files (index.html, style.css, script.js) from SPIFFS.  </li> <li>webSocketEvent(): The callback function for handling WebSocket events (connect, disconnect, text messages). Parses incoming JSON commands from the web UI.  </li> <li>broadcastWebSocketData(): Constructs and sends JSON data containing the current system status to all connected WebSocket clients.  </li> <li>tasks.h / tasks.cpp: </li> <li>Defines and implements the FreeRTOS tasks.  </li> <li>networkTask(void *pvParameters): The function executed by Core 0.  </li> <li>mainAppTask(void *pvParameters): The function executed by Core 1.  </li> <li>Includes extern TaskHandle_t declarations for task handles (definitions are in main.cpp).</li> </ul> <p>This modular structure makes the codebase easier to understand, debug, and extend.</p> <p>Previous Chapter: Hardware | Next Chapter: Setup and Installation</p>"},{"location":"04-setup-and-installation/","title":"Chapter 4: Setup and Installation","text":"<p>This chapter guides you through assembling the hardware, setting up the software environment using PlatformIO, and uploading the firmware and web files to your ESP32.</p>"},{"location":"04-setup-and-installation/#41-hardware-assembly-tips","title":"4.1. Hardware Assembly Tips","text":"<p>(No changes to this section, as OTA is primarily a software/network feature)</p>"},{"location":"04-setup-and-installation/#42-software-setup-platformio","title":"4.2. Software Setup (PlatformIO)","text":"<p>(Minor addition for clarity on build environment name)</p> <ol> <li>Install Visual Studio Code: Download and install from code.visualstudio.com.  </li> <li>Install PlatformIO IDE Extension: </li> <li>Open VS Code.  </li> <li>Go to the Extensions view (Ctrl+Shift+X or click the square icon on the sidebar).  </li> <li>Search for \"PlatformIO IDE\" and install it.  </li> <li>Obtain Project Files: </li> <li>Clone the project repository from GitHub or download the source code ZIP.  </li> <li>Open Project in PlatformIO: </li> <li>In VS Code, go to File &gt; Open Folder... and select the root folder of the cloned/downloaded project.  </li> <li>PlatformIO should automatically recognize the platformio.ini file and set up the project environment.  </li> <li>Review platformio.ini: </li> <li>Open the platformio.ini file in the project root.  </li> <li>Ensure the board setting matches your specific ESP32 development board model.  </li> <li>Verify the lib_deps section lists all required libraries.  </li> <li>Note the PlatformIO environment name (e.g., upesy_wroom or esp32_fancontrol as defined in PIO_ENV in the GitHub Actions workflow and PIO_BUILD_ENV_NAME in config.h). This is important for GitHub OTA release asset naming. </li> <li>Configure Default WiFi (Optional): </li> <li>Open src/main.cpp.  </li> <li>Locate char current_ssid[64] \\= \"YOUR_WIFI_SSID\"; and char current_password[64] \\= \"YOUR_WIFI_PASSWORD\";.  </li> <li>You can change these to your network's credentials for default connection attempts.</li> </ol>"},{"location":"04-setup-and-installation/#43-uploading-firmware-and-filesystem-data","title":"4.3. Uploading Firmware and Filesystem Data","text":"<p>The project requires both the main firmware and the web interface files (HTML, CSS, JS) to be uploaded to the ESP32. Additionally, for OTA updates from GitHub, a Root CA certificate file needs to be on the SPIFFS.</p> <ol> <li>Prepare Files for SPIFFS: </li> <li>In the root directory of your PlatformIO project, ensure you have a data folder.  </li> <li>Place your index.html, style.css, and script.js files directly inside this data folder.  </li> <li>For GitHub OTA Updates: <ul> <li>The GitHub Actions release pipeline is configured to automatically download the appropriate Root CA certificate and place it as github_api_ca.pem (or the name defined by CA_CERT_FILENAME in the workflow) into the data directory during the GitHub Actions run.  </li> <li>When you build and upload the filesystem image locally for the first time or for testing, you would need to manually place the correct Root CA certificate file (e.g., github_api_ca.pem, matching GITHUB_ROOT_CA_FILENAME in config.h) into your local data folder before building the SPIFFS image. The device firmware will then load this certificate from SPIFFS at boot.  </li> <li>The release assets generated by the GitHub Actions pipeline will already have this CA certificate embedded in their spiffs.bin. </li> </ul> </li> <li>Build and Upload Filesystem Image (SPIFFS): </li> <li>This step uploads the contents of the data folder (including your web files and the CA certificate if placed manually) to the ESP32's SPIFFS partition.  </li> <li>In VS Code with PlatformIO: <ul> <li>Click on the PlatformIO icon (alien head) in the VS Code activity bar.  </li> <li>Expand your project environment.  </li> <li>Under \"Platform\", find and click on \"Upload Filesystem Image\".  </li> </ul> </li> <li>Using PlatformIO Core CLI: <ul> <li>Run the command: pio run --target uploadfs  </li> </ul> </li> <li>This process builds a SPIFFS image and uploads it. You need to do this whenever you change files in the data folder locally.  </li> <li>Build and Upload Firmware: </li> <li>This compiles your C++ code and uploads the resulting binary to the ESP32.  </li> <li>Initial Upload (Serial): <ul> <li>Ensure upload_protocol \\= espota is commented out or not present in platformio.ini.  </li> <li>In VS Code with PlatformIO: Click \"Build\" then \"Upload\".  </li> <li>Using PlatformIO Core CLI: pio run --target upload  </li> </ul> </li> <li>Subsequent Uploads (OTA via ElegantOTA Web UI): <ul> <li>After the initial serial upload, if WiFi is connected, you can navigate to http://\\&lt;ESP32_IP_ADDRESS&gt;/update to upload new firmware.bin or spiffs.bin files.  </li> </ul> </li> <li>Subsequent Uploads (OTA via PlatformIO): <ul> <li>Uncomment upload_protocol \\= espota in platformio.ini.  </li> <li>Set upload_port \\= \\&lt;ESP32_IP_ADDRESS_OR_HOSTNAME&gt;.  </li> <li>In VS Code with PlatformIO: Click \"Upload\".  </li> <li>Using PlatformIO Core CLI: pio run --target upload</li> </ul> </li> </ol> <p>After completing these steps, your ESP32 should be running the fan controller firmware. The GitHub OTA update feature will rely on the CA certificate being present in the SPIFFS image.</p> <p>Previous Chapter: Software | Next Chapter: Usage Guide</p>"},{"location":"05-usage-guide/","title":"Chapter 5: Usage Guide","text":"<p>This chapter explains how to interact with and use the ESP32 PC Fan Controller after setup and installation, including the new MQTT Discovery and OTA update features.</p>"},{"location":"05-usage-guide/#51-first-boot-and-initial-state","title":"5.1. First Boot and Initial State","text":"<p>(No significant changes, but firmware version is now more prominent)</p> <ul> <li>Power On: After uploading the firmware and filesystem, power on your ESP32 fan controller.  </li> <li>Debug Mode Check: (As before)  </li> <li>Initial WiFi &amp; MQTT State: (As before)  </li> <li>LCD Display: The LCD will initialize and show \"Fan Controller\" and the current FIRMWARE_VERSION briefly. Once the mainAppTask starts, it will switch to the normal status display.  </li> <li>Fan State: (As before)  </li> <li>Settings: (As before)  </li> <li>Root CA for OTA: The device attempts to load a Root CA certificate from /github_api_ca.pem (or as defined by GITHUB_ROOT_CA_FILENAME) on SPIFFS. If not found or empty, secure OTA updates from GitHub will fail.</li> </ul>"},{"location":"05-usage-guide/#52-lcd-menu-navigation","title":"5.2. LCD Menu Navigation","text":"<p>The primary way to configure the device standalone is through the LCD menu system.</p> <ul> <li>Button Functions: (Menu, Up, Down, Select, Back)  </li> <li>Main Menu Flow: </li> <li>Normal Status Display <ul> <li>Press BTN_MENU_PIN -&gt; Main Menu </li> <li>&gt;WiFi Settings  </li> <li>MQTT Settings  </li> <li>OTA Update (New Menu Item)  </li> <li>View Status (Exits menu)  </li> </ul> </li> <li>WiFi Settings Menu: (As before)  </li> <li>WiFi Scan Menu (WIFI_SCAN): (As before)  </li> <li>Password Entry Menu (WIFI_PASSWORD_ENTRY): (As before)  </li> <li>MQTT Settings Menu: (As before)  </li> <li>MQTT Entry Screens: (As before)  </li> <li>MQTT Discovery Settings Menu: (As before)  </li> <li>MQTT Discovery Prefix Entry Menu: (As before)  </li> <li>OTA Update Screen (OTA_UPDATE_SCREEN) (New): <ul> <li>Displays \"Firmware Update\".  </li> <li>Options:  </li> <li>&gt;Check &amp; Update: (If WiFi is connected) Initiates a check with GitHub for the latest release. If a newer version is found, it will attempt to download and install firmware (and SPIFFS if available in the release). The LCD will show status messages like \"Fetching...\", \"Updating FW...\", \"Updating FS...\", \"Rebooting...\".  </li> <li>&gt;Back to Main: Returns to the main menu.  </li> <li>If an OTA update is already in progress, this screen will show \"OTA In Progress:\" and the current status message.  </li> </ul> </li> <li>Confirm Reboot Menu (CONFIRM_REBOOT): (As before)</li> </ul>"},{"location":"05-usage-guide/#53-serial-command-interface-debug-mode","title":"5.3. Serial Command Interface (Debug Mode)","text":"<ul> <li>Activation: DEBUG_ENABLE_PIN HIGH at boot.  </li> <li>Connection: Serial Monitor at 115200 baud.  </li> <li>Key Serial Commands (type help for full list): </li> <li>status: Displays current operational status including WiFi, MQTT state, Discovery settings, and current OTA status/firmware version. </li> <li>set_mode auto / set_mode manual \\&lt;percentage&gt;  </li> <li>WiFi commands (as before)  </li> <li>MQTT commands (as before)  </li> <li>MQTT Discovery commands (as before)  </li> <li>ota_update (New): If WiFi is connected, triggers a check for new firmware/SPIFFS releases on GitHub. If a newer version is found, it attempts to download and apply the update. Progress and status messages are printed to the serial console.  </li> <li>Fan curve commands (as before)  </li> <li>reboot</li> </ul>"},{"location":"05-usage-guide/#54-web-interface-if-wifi-enabled","title":"5.4. Web Interface (If WiFi Enabled)","text":"<ul> <li>Access via ESP32's IP address.  </li> <li>Real-time status display (Temp, Fan Speed/RPM, Mode, Firmware Version).  </li> <li>Mode control (Auto/Manual buttons).  </li> <li>Manual speed slider.  </li> <li>Fan Curve Editor.  </li> <li>MQTT Configuration Section.  </li> <li>MQTT Discovery Configuration Section.  </li> <li>OTA Update Section (New): </li> <li>Displays current firmware version.  </li> <li>Shows current OTA status message (e.g., \"Idle\", \"Checking...\", \"Updating FW...\", \"Error...\").  </li> <li>A button \"Check for Updates &amp; Install\". Clicking this (after confirmation) triggers the GitHub OTA update check process. The button will be disabled while an update is in progress.  </li> <li>ElegantOTA Manual Update (New): </li> <li>Navigate to http://\\&lt;ESP32_IP_ADDRESS&gt;/update.  </li> <li>This page allows manual upload of firmware.bin or spiffs.bin files for OTA update. This is separate from the GitHub-based OTA.</li> </ul>"},{"location":"05-usage-guide/#55-mqtt-usage-for-home-automation-with-home-assistant-discovery","title":"5.5. MQTT Usage for Home Automation (with Home Assistant Discovery)","text":"<p>(No direct changes to MQTT usage itself, but the status_json payload now includes firmware version and OTA status)</p> <ul> <li>Status Topic (status_json): Now includes firmwareVersion, otaInProgress, and otaStatusMessage fields.</li> </ul>"},{"location":"05-usage-guide/#56-over-the-air-ota-updates","title":"5.6. Over-the-Air (OTA) Updates","text":"<p>The device supports two methods for OTA updates:</p> <ol> <li>ElegantOTA (Manual Web Upload): </li> <li>Access: http://\\&lt;ESP32_IP_ADDRESS&gt;/update  </li> <li>Functionality: Allows you to manually upload a compiled firmware.bin file or a spiffs.bin (filesystem image) directly to the device through your web browser.  </li> <li>Use Case: Useful for deploying specific builds, testing, or if the GitHub OTA mechanism is unavailable.  </li> <li>GitHub Release Updater (Automated Check &amp; Install): </li> <li>Trigger: Can be initiated from the LCD Menu, Web UI button, or Serial Command (ota_update).  </li> <li>Process: <ol> <li>The ESP32 connects to the GitHub API (securely, using the CA certificate from SPIFFS) to fetch information about the latest release from the dnviti/SmartWifiFanController repository.  </li> <li>It compares the tag name (version) of the latest release with the FIRMWARE_VERSION compiled into the currently running firmware.  </li> <li>If a newer version is found:  <ul> <li>It downloads the firmware_PIO_BUILD_ENV_NAME_vX.Y.Z.bin asset.  </li> <li>It applies the firmware update using HTTPUpdate. The device will reboot after a successful firmware update.  </li> <li>If a spiffs_PIO_BUILD_ENV_NAME_vX.Y.Z.bin asset is also found in the release, and the firmware update was successful (leading to a reboot), the intention is for the system to handle this. Currently, the SPIFFS update is attempted sequentially after firmware in the same function; if firmware reboots, a more robust two-stage mechanism (e.g., using NVS flag) would be needed for automatic SPIFFS update post-reboot. For now, if firmware updates and reboots, you might need to trigger the OTA again to get the SPIFFS, or update SPIFFS manually via ElegantOTA or serial.  </li> </ul> </li> <li>If the firmware is already up-to-date, or if an error occurs (e.g., no WiFi, GitHub unreachable, no valid assets), an appropriate status message is shown.  </li> </ol> </li> <li>Root CA Certificate: This process relies on a valid Root CA certificate named github_api_ca.pem (or as defined by GITHUB_ROOT_CA_FILENAME in config.h) being present in the ESP32's SPIFFS filesystem. This file is automatically included in the spiffs.bin generated by the GitHub Actions release pipeline.</li> </ol> <p>Previous Chapter: Setup and Installation | Next Chapter: Technical Details &amp; Protocols</p>"},{"location":"06-technical-details/","title":"Chapter 6: Technical Details &amp; Protocols","text":"<p>This chapter delves into the specific technologies, protocols, and implementation details used within the ESP32 PC Fan Controller project.</p>"},{"location":"06-technical-details/#61-pwm-fan-control","title":"6.1. PWM Fan Control","text":"<p>(No changes)</p>"},{"location":"06-technical-details/#62-i2c-communication","title":"6.2. I2C Communication","text":"<p>(No changes)</p>"},{"location":"06-technical-details/#63-fan-tachometer-rpm-sensing","title":"6.3. Fan Tachometer (RPM Sensing)","text":"<p>(No changes)</p>"},{"location":"06-technical-details/#64-wifi-and-networking-web-server-websockets","title":"6.4. WiFi and Networking (Web Server &amp; WebSockets)","text":"<ul> <li>WiFi Client Mode (STA): The ESP32 connects to an existing WiFi network. The hostname is dynamically set to fancontrol-[macaddress] for easier network identification. </li> <li>ESPAsyncWebServer Library: </li> <li>Used for creating an HTTP server.  </li> <li>Serves static files (index.html, style.css, script.js) from SPIFFS.  </li> <li>Hosts the ElegantOTA endpoint (/update) for manual OTA updates. </li> <li>WebSockets (WebSocketsServer library): </li> <li>Provides persistent, full-duplex communication for the web UI.  </li> <li>Transmits OTA status messages and receives OTA trigger commands. </li> <li>Data Format: JSON (ArduinoJson library) for WebSocket data.</li> </ul>"},{"location":"06-technical-details/#65-mqtt-integration-for-home-automation","title":"6.5. MQTT Integration for Home Automation","text":"<p>(Status JSON now includes OTA info)</p> <ul> <li>Protocol: MQTT.  </li> <li>Library: PubSubClient.  </li> <li>Configuration: (As before).  </li> <li>Home Assistant MQTT Discovery: (As before).  </li> <li>Topics and Payloads: </li> <li>Status Topic (JSON): (e.g., YOUR_BASE_TOPIC/status_json) - Publishes a comprehensive JSON object. Now includes firmwareVersion, otaInProgress, and otaStatusMessage. </li> <li>Other topics (as before).  </li> <li>Processing: (As before).</li> </ul>"},{"location":"06-technical-details/#66-spiffs-filesystem-usage","title":"6.6. SPIFFS Filesystem Usage","text":"<ul> <li>Web Interface Files: Stores index.html, style.css, script.js.  </li> <li>Root CA Certificate for OTA: Stores the Root CA certificate (e.g., /github_api_ca.pem) used for secure HTTPS connections to GitHub for OTA updates. This file is loaded into memory at boot. The GitHub Actions pipeline includes the latest CA in the spiffs.bin of releases.</li> </ul>"},{"location":"06-technical-details/#67-nvs-non-volatile-storage-for-persistence","title":"6.7. NVS (Non-Volatile Storage) for Persistence","text":"<p>(No changes)</p>"},{"location":"06-technical-details/#68-conditional-debug-mode","title":"6.8. Conditional Debug Mode","text":"<p>(No changes)</p>"},{"location":"06-technical-details/#69-dual-core-operation-freertos-tasks","title":"6.9. Dual-Core Operation (FreeRTOS Tasks)","text":"<ul> <li>Core 0 (networkTask): Handles WiFi, ESPAsyncWebServer (including ElegantOTA), WebSockets, MQTT client.  </li> <li>Core 1 (mainAppTask): Handles main application logic, sensors, LCD, buttons, serial commands. The GitHub OTA check and update process (HTTPClient, HTTPUpdate) are initiated from this core's context when triggered, which can be blocking during the download/flash phases.</li> </ul>"},{"location":"06-technical-details/#610-over-the-air-ota-updates","title":"6.10. Over-the-Air (OTA) Updates","text":"<p>The controller implements two OTA update mechanisms:</p> <ol> <li>ElegantOTA (Manual Web Upload): </li> <li>Library: ayushsharma82/ElegantOTA.  </li> <li>Interface: Provides a web page at the /update endpoint of the ESP32's IP address.  </li> <li>Functionality: Allows users to manually upload pre-compiled firmware.bin or spiffs.bin files directly to the device.  </li> <li>Initialization: ElegantOTA.begin(\\&amp;server); is called in networkTask after the web server starts. ElegantOTA.loop() is also called in networkTask.  </li> <li>GitHub Release Updater (Automated Check &amp; Install): </li> <li>Module: Custom logic in ota_updater.h and ota_updater.cpp.  </li> <li>Trigger: Can be initiated via LCD menu, Web UI, or a serial command (ota_update).  </li> <li>Process: <ol> <li>Fetch Latest Release Info: <ul> <li>Makes an HTTPS GET request to the GitHub API (GITHUB_API_LATEST_RELEASE_URL).  </li> <li>Uses WiFiClientSecure configured with a Root CA certificate loaded from SPIFFS (GITHUB_API_ROOT_CA_STRING loaded from GITHUB_ROOT_CA_FILENAME).  </li> <li>Parses the JSON response (using ArduinoJson) to find the tag_name (version) and asset download URLs for firmware (firmware_PIO_BUILD_ENV_NAME_vX.Y.Z.bin) and SPIFFS (spiffs_PIO_BUILD_ENV_NAME_vX.Y.Z.bin). PIO_BUILD_ENV_NAME must match the environment name used in the GitHub Actions release workflow.  </li> </ul> </li> <li>Version Comparison: <ul> <li>Compares the fetched tag_name with the FIRMWARE_VERSION define.  </li> </ul> </li> <li>Update Execution (if newer version found): <ul> <li>Uses the HTTPUpdate library.  </li> <li>Firmware Update: Calls httpUpdate.update(client, firmwareURL).  </li> <li>SPIFFS Update: Calls httpUpdate.updateSpiffs(client, spiffsURL).  </li> <li>Both use WiFiClientSecure configured with the loaded Root CA from SPIFFS.  </li> <li>The device reboots automatically after a successful update by HTTPUpdate.  </li> </ul> </li> </ol> </li> <li>Root CA Management: The Root CA certificate is stored on SPIFFS. The GitHub Actions workflow is designed to download the latest relevant CA during its build process and include it in the spiffs.bin of the release assets. This allows the CA to be updated via a SPIFFS OTA update.  </li> <li>Security: Relies on HTTPS for communication with GitHub. The validity of the connection depends on the correctness and currency of the Root CA certificate stored on SPIFFS.</li> </ol> <p>Previous Chapter: Usage Guide | Next Chapter: Troubleshooting</p>"},{"location":"07-troubleshooting/","title":"Chapter 7: Troubleshooting","text":"<p>This chapter provides solutions to common issues you might encounter while building and using the ESP32 PC Fan Controller.</p> <ul> <li>No LCD Output / Gibberish on LCD: </li> <li>Check Wiring: Verify SDA, SCL, VCC, and GND connections between the ESP32 and the I2C LCD module.  </li> <li>I2C Address: The default I2C address in the code is 0x27. Your module might use a different address (e.g., 0x3F). Use an I2C scanner sketch to find the correct address and update LiquidCrystal_I2C lcd(0x27, 16, 2); accordingly.  </li> <li>Pull-up Resistors: Ensure 4.7k\u03a9 to 10k\u03a9 pull-up resistors are present on both the SDA and SCL lines, connected to 3.3V. Some modules have them built-in.  </li> <li>Power: Confirm the LCD module is receiving the correct voltage (usually 5V for the backpack, but the I2C lines are 3.3V logic with the ESP32).  </li> <li>Contrast: Some LCDs have a contrast potentiometer on the backpack. Try adjusting it.  </li> <li>Fan Not Spinning or Not Responding to PWM: </li> <li>12V Power: Ensure the fan is receiving a stable 12V supply directly.  </li> <li>PWM Signal Wiring: Double-check the connection from the ESP32's FAN_PWM_PIN to the fan's control wire (Pin 4).  </li> <li>Logic Level Shifter (CRITICAL): Most PC fans expect a 5V PWM signal. The ESP32 outputs 3.3V. Using a 3.3V to 5V logic level shifter is highly recommended and often necessary for proper operation. Without it, fans might not spin, spin at a fixed speed, or not respond to the full PWM range.  </li> <li>PWM Frequency: The code sets PWM_FREQ to 25000 (25kHz), which is standard. Ensure this is correctly configured.  </li> <li>Fan Type: Confirm you are using a 4-pin PWM fan. 3-pin DC fans require voltage control, not PWM on a dedicated line, and would need different circuitry (e.g., a MOSFET to switch the main power or an L298N).  </li> <li>Ground Connection: Ensure a common ground between the ESP32, the 12V power supply for the fan, and the fan itself.  </li> <li>No RPM Reading or Incorrect RPM: </li> <li>Tachometer Wiring: Verify the fan's tachometer (sense) wire (Pin 3) is connected to the ESP32's FAN_TACH_PIN_ACTUAL.  </li> <li>Pull-up Resistor: A 10k\u03a9 pull-up resistor from the tachometer line to 3.3V is essential.  </li> <li>PULSES_PER_REVOLUTION: Most PC fans output 2 pulses per revolution. If you get half or double the expected RPM, this constant might need adjustment for your specific fan.  </li> <li>ISR and Pin: Ensure the interrupt is correctly attached to the FAN_TACH_PIN_ACTUAL in setup().  </li> <li>Fan Health: Some very cheap or old fans might have faulty tachometer outputs.  </li> <li>WiFi Connection Issues (No Connection, Drops): </li> <li>Credentials: Double-check the SSID and password entered via the LCD menu or serial commands. They are case-sensitive.  </li> <li>Signal Strength: Ensure the ESP32 has adequate WiFi signal. Metal PC cases can significantly attenuate signals. Consider using an ESP32 module with a U.FL connector for an external antenna if issues persist.  </li> <li>Router Configuration: Check if your router has any MAC filtering or other security settings that might prevent the ESP32 from connecting.  </li> <li>Power Supply to ESP32: Unstable power to the ESP32 can cause WiFi drops. Ensure your 5V supply from the buck converter is clean and stable.  </li> <li>Serial Logs (Debug Mode): Enable debug mode (DEBUG_ENABLE_PIN HIGH) and check the serial monitor for detailed WiFi connection messages and error codes.  </li> <li>Web Interface Not Loading or Not Updating: </li> <li>WiFi Connection: Confirm the ESP32 is connected to WiFi and you are using the correct IP address in your browser. The device accessing the web UI must be on the same network as the ESP32.  </li> <li>SPIFFS Upload: Ensure index.html, style.css, and script.js were correctly uploaded to the ESP32's SPIFFS using the \"Upload Filesystem Image\" task in PlatformIO. If these files are missing, the server will return 404 errors. Check serial logs for SPIFFS mount errors during boot.  </li> <li>WebSocket Connection: Open your browser's developer console (usually F12). Check for WebSocket connection errors in the console tab. The JavaScript in script.js attempts to connect to ws://\\&lt;ESP32_IP_ADDRESS&gt;:81/.  </li> <li>Firewall: Ensure no firewall on your PC or network is blocking WebSocket connections on port 81.  </li> <li>Settings Not Being Saved (NVS Issues): </li> <li>Serial Logs (Debug Mode): Check for any NVS-related error messages like \"Failed to open namespace\" or errors during put operations.  </li> <li>NVS Full/Corrupted: While unlikely for this amount of data, NVS can become corrupted. PlatformIO might have tools to erase the entire flash or NVS partition, after which settings would revert to defaults.  </li> <li>Namespace/Key Typos: Ensure consistency in namespace names and keys used in save... and load... NVS functions.  </li> <li>Serial Command Interface Not Working: </li> <li>DEBUG_ENABLE_PIN: Verify this pin is pulled HIGH at boot time. The debug LED (LED_DEBUG_PIN) should be ON.  </li> <li>Baud Rate: Ensure your Serial Monitor is set to 115200 baud.  </li> <li>Serial Port: Confirm you have selected the correct COM port for the ESP32 in your IDE.  </li> <li>Serial.begin() Call: The code is designed to only call Serial.begin() if serialDebugEnabled is true. If the pin is low, no serial communication will be initialized.  </li> <li>ESP32 Keeps Rebooting (Boot Loop): </li> <li>Power Issues: Insufficient or unstable power is a common cause. Check your 12V source and the 5V output of your buck converter.  </li> <li>Hardware Shorts: Carefully inspect your wiring for any short circuits.  </li> <li>Software Crash: A bug in the code (e.g., null pointer dereference, stack overflow in a task) can cause a crash and reboot. Enable serial debug and observe the output for crash reports or Guru Meditation Errors. The ESP32 often prints a backtrace that can help pinpoint the issue.  </li> <li>Stack Overflow: If tasks are crashing, their allocated stack size (e.g., 10000 words in xTaskCreatePinnedToCore) might be insufficient. This is less likely with the current setup but possible if significant local variables or deep function calls are added.  </li> <li>Compilation Errors: </li> <li>Library Not Found: Ensure all required libraries are correctly installed (via PlatformIO's lib_deps or Arduino Library Manager).  </li> <li>\"'function' was not declared in this scope\": Often due to missing forward declarations or incorrect #include order. Ensure header files are included before their contents are used.  </li> <li>Board Selection: Double-check that the correct ESP32 board is selected in your IDE.</li> </ul> <p>By systematically checking these areas and utilizing the serial debug output, most common problems can be diagnosed and resolved.</p> <p>Previous Chapter: Technical Details &amp; Protocols | Next Chapter: Future Enhancements</p>"},{"location":"08-future-enhancements/","title":"Chapter 8: Future Enhancements","text":"<p>This ESP32 PC Fan Controller project provides a solid foundation with comprehensive features including MQTT and Home Assistant Discovery. Here are several potential enhancements and new features that could be added in the future to further improve its capabilities and user experience:</p> <ol> <li>Multiple Fan Channel Control: * Hardware: Add more PWM output channels (each requiring a logic level shifter) and tachometer input channels (each requiring a pull-up and a dedicated GPIO with interrupt capability).  </li> <li>Software: * Modify data structures to store settings (mode, manual speed, curve) and status (RPM, current speed) for each fan channel.  <ul> <li>Update the LCD menu, web interface, and serial commands to select and configure individual fan channels.  </li> <li>Expand broadcastWebSocketData and MQTT status payloads to include data for all channels.  </li> <li>Update Home Assistant MQTT Discovery to create separate entities for each fan channel.  </li> </ul> </li> <li>Graphical OLED Display Upgrade: * Replace the 16x2 character LCD with a graphical I2C OLED display (e.g., SSD1306 128x64 or SH1106 128x64).  </li> <li>Software: * Integrate a suitable OLED library (e.g., Adafruit SSD1306, U8g2).  <ul> <li>Redesign the display output to take advantage of graphical capabilities:  </li> <li>More visually appealing status screens.  </li> <li>Graphical representation of the fan curve.  </li> <li>Improved menu navigation and text rendering.  </li> </ul> </li> <li>Fan Curve Editing via LCD Menu: * Implement a more complex menu system on the LCD (easier with an OLED) to allow users to add, modify, and delete points in the fan curve directly on the device, without needing the web UI, MQTT, or serial.  </li> <li>This would require careful UI design for inputting temperature and PWM values using the limited physical buttons.  </li> <li>Advanced WiFi Manager / Captive Portal: * Integrate a library like \"WiFiManager\" (ESP32 compatible version).  </li> <li>If the ESP32 cannot connect to a previously configured WiFi network (or if no network is configured), it would automatically start in Access Point (AP) mode.  </li> <li>Users could then connect their phone/laptop to this ESP32's AP. Upon connection, a captive portal (a special web page served by the ESP32) would appear, allowing the user to scan for local WiFi networks and enter credentials.  </li> <li>This would eliminate the need for initial WiFi setup via LCD or serial commands for basic connectivity.  </li> <li>OTA (Over-The-Air) Firmware Updates: * Implement OTA update functionality (e.g., using ArduinoOTA library or AsyncElegantOTA which integrates with ESPAsyncWebServer).  </li> <li>This would allow updating the ESP32's firmware wirelessly over the WiFi network, without needing a physical USB connection. Invaluable for deploying bug fixes and new features.  </li> <li>More Sophisticated Fan Control Algorithms: * PID Control: Implement a Proportional-Integral-Derivative (PID) controller for fan speed based on temperature. This could lead to smoother and more responsive temperature regulation, minimizing oscillations in fan speed.  </li> <li>Hysteresis: Add hysteresis to temperature thresholds in the fan curve to prevent rapid fan speed changes if the temperature hovers around a set point.  </li> <li>User Profiles for Settings: * Allow users to save and load multiple distinct profiles (e.g., \"Silent Mode,\" \"Gaming Mode,\" \"Max Cooling\"). Each profile could have its own fan curve(s) and mode settings.  </li> <li>This would require expanding the NVS storage scheme.  </li> <li>Alerts and Notifications: * Implement alerts (e.g., on LCD, via WebSockets to web UI, via MQTT, or even an audible buzzer if hardware is added) for conditions like:    * Temperature exceeding a critical threshold.    * Fan RPM dropping to zero (indicating a failed fan).  </li> <li>Logging to SPIFFS or SD Card: * Log temperature, fan speeds, and RPM data over time to a file on SPIFFS or an SD card (if an SD card module is added). This data could then be downloaded via the web interface for analysis.  </li> <li>Refined Home Automation Integration: <ul> <li>More Granular MQTT Topics (Optional): Provide an option to publish individual status items (temp, speed, rpm) to separate, simple topics in addition to the main JSON status payload, for easier use with systems that prefer simpler topic structures or don't handle JSON well.  </li> <li>MQTT Commands for Individual Curve Points: Allow setting/getting individual fan curve points via dedicated MQTT topics, for more granular remote fan curve management beyond the full JSON string.  </li> </ul> </li> <li>Power Consumption Monitoring: * If appropriate current sensing hardware is added, the ESP32 could monitor and display the power consumption of the connected fans.  </li> <li>Enclosure and PCB Refinements: * Iterate on custom PCB design for better component layout, EMI reduction, and ease of assembly.  <ul> <li>Design more sophisticated and aesthetically pleasing enclosures with features like integrated light pipes for status LEDs, better ventilation, and easier mounting.</li> </ul> </li> </ol> <p>These enhancements range from relatively simple software additions to more complex hardware and software redesigns, offering a roadmap for continued development and improvement of the ESP32 PC Fan Controller.</p> <p>Previous Chapter: Troubleshooting</p>"}]}