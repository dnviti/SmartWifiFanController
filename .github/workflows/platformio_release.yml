name: Create Release and Build Artifacts

on:
  push:
    branches:
      - "release/v*" # Trigger on branches like release/v1.0.0, release/v1.2.3-alpha

permissions:
  contents: write # Needed to create releases and upload assets

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    env:
      PIO_ENV: esp32_fancontrol # Your PlatformIO environment name from platformio.ini
      # Filename for the downloaded CA certificate
      CA_CERT_FILENAME: "github_root_ca.pem"
      GITHUB_API_HOST: "api.github.com"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.9" # PlatformIO recommends Python 3.9+

      - name: Install PlatformIO Core and OpenSSL
        run: |
          pip install -U platformio
          sudo apt-get update && sudo apt-get install -y openssl

      - name: Install project dependencies
        run: pio pkg install --global # Installs libraries globally in the runner

      - name: Create data directory if it doesn't exist
        run: mkdir -p data

      - name: Download GitHub API Root CA Certificate
        run: |
          echo "Attempting to download Root CA for ${{ env.GITHUB_API_HOST }}..."
          # Connect to the server and print the certificate chain.
          # Then, use awk to extract the *last* certificate in the chain (usually the Root CA).
          openssl s_client -showcerts -connect ${{ env.GITHUB_API_HOST }}:443 -servername ${{ env.GITHUB_API_HOST }} < /dev/null 2>/dev/null | \
          awk '
            /BEGIN CERTIFICATE/ {
              buffer=""
              in_cert=1
            }
            in_cert {
              buffer = buffer $0 "\n"
            }
            /END CERTIFICATE/ {
              if (in_cert) {
                # Overwrite last_cert with the current full certificate block
                # This ensures that by the end, last_cert holds the final certificate in the chain
                last_cert=buffer
                in_cert=0 
              }
            }
            END {
              if (last_cert != "") {
                print "Found a certificate, saving as data/${{ env.CA_CERT_FILENAME }}"
                printf "%s", last_cert > "data/${{ env.CA_CERT_FILENAME }}"
              } else {
                echo "Error: Could not extract any certificate from ${{ env.GITHUB_API_HOST }}"
                exit 1
              }
            }
          '
          if [ ! -s data/${{ env.CA_CERT_FILENAME }} ]; then
            echo "Error: Failed to download or CA certificate file (data/${{ env.CA_CERT_FILENAME }}) is empty."
            exit 1
          fi
          echo "GitHub API Root CA certificate downloaded successfully to data/${{ env.CA_CERT_FILENAME }}."
          echo "--- Certificate Content (first 5 lines) ---"
          head -n 5 data/${{ env.CA_CERT_FILENAME }}
          echo "----------------------------------------"
          ls -l data/
        shell: bash

      - name: Build Firmware
        run: pio run -e ${{ env.PIO_ENV }}

      - name: Build Filesystem Image (includes downloaded CA cert)
        run: pio run -e ${{ env.PIO_ENV }} --target buildfs

      - name: Get Version from Branch
        id: get_version
        run: |
          BRANCH_NAME="${GITHUB_REF#refs/heads/release/}"
          echo "VERSION_TAG=${BRANCH_NAME}" >> $GITHUB_ENV
        shell: bash

      - name: Determine Asset Names and Prepare Files
        id: asset_names
        run: |
          # Define local shell variables for the asset names
          FIRMWARE_NAME="firmware_${{ env.PIO_ENV }}_${{ env.VERSION_TAG }}.bin"
          SPIFFS_NAME="spiffs_${{ env.PIO_ENV }}_${{ env.VERSION_TAG }}.bin"

          # Output these names to GITHUB_ENV so subsequent steps can use them
          echo "FIRMWARE_ASSET_NAME=${FIRMWARE_NAME}" >> $GITHUB_ENV
          echo "SPIFFS_ASSET_NAME=${SPIFFS_NAME}" >> $GITHUB_ENV

          # Copy built files using the local shell variables
          echo "Copying .pio/build/${{ env.PIO_ENV }}/firmware.bin to ${FIRMWARE_NAME}"
          cp .pio/build/${{ env.PIO_ENV }}/firmware.bin "${FIRMWARE_NAME}"

          echo "Copying .pio/build/${{ env.PIO_ENV }}/spiffs.bin to ${SPIFFS_NAME}"
          cp .pio/build/${{ env.PIO_ENV }}/spiffs.bin "${SPIFFS_NAME}"

          echo "Listing files in current directory:"
          ls -l
        shell: bash

      - name: Create Release from Branch
        id: create_tagged_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.VERSION_TAG }}
          name: Release ${{ env.VERSION_TAG }}
          body: |
            Automated release for version ${{ env.VERSION_TAG }} (from branch ${{ github.ref_name }}).
            Contains firmware and SPIFFS filesystem image.
            The SPIFFS image includes the Root CA certificate for `${{ env.GITHUB_API_HOST }}` (downloaded during build) as `${{ env.CA_CERT_FILENAME }}`.
          draft: false
          prerelease: ${{ contains(env.VERSION_TAG, '-') }}
          files:
            | # These now refer to the variables set in GITHUB_ENV by the previous step
            ${{ env.FIRMWARE_ASSET_NAME }}
            ${{ env.SPIFFS_ASSET_NAME }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Delete 'latest' Release and Tag if they exist
        uses: dev-drprasad/delete-tag-and-release@v1.1
        with:
          tag_name: latest
          delete_release: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Create 'latest' Release
        id: create_latest_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: latest
          name: Latest Build
          body: |
            This is the latest automated build.
            Based on version: ${{ env.VERSION_TAG }} (from branch ${{ github.ref_name }})
            Contains firmware and SPIFFS filesystem image.
            The SPIFFS image includes the Root CA certificate for `${{ env.GITHUB_API_HOST }}` (downloaded during build) as `${{ env.CA_CERT_FILENAME }}`.
          draft: false
          prerelease: false
          files: | # These now refer to the variables set in GITHUB_ENV
            ${{ env.FIRMWARE_ASSET_NAME }}
            ${{ env.SPIFFS_ASSET_NAME }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
