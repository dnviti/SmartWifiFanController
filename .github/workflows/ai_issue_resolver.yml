name: AI Issue Resolver (Experimental)

on:
  workflow_dispatch: # Allows manual triggering
    inputs:
      issue_number:
        description: 'Optional: Specific issue number to process (leave blank to process a batch)'
        required: false
        default: ''
      max_issues_to_process:
        description: 'Maximum number of open issues to attempt to process in this run'
        required: false
        default: '1'
      allow_pr_creation:
        description: 'Set to "true" to allow the script to create Pull Requests'
        required: true
        default: 'false' # Default to false for safety

permissions:
  contents: write      # To create branches, commit, push
  issues: read         # To read issues
  pull-requests: write # To create pull requests

jobs:
  resolve_issues_with_ai:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }} # CRITICAL: Store your Gemini API Key as a secret
      TARGET_BRANCH: main # Or your development branch like 'develop'
      GEMINI_MODEL: "gemini-2.5-pro-preview-05-06" # Updated Gemini Model
      # User and email for AI commits
      GIT_COMMIT_USER_NAME: "AI Issue Resolver Bot"
      GIT_COMMIT_USER_EMAIL: "ai-bot@users.noreply.github.com"
      # Repository NWO (name with owner)
      GITHUB_REPOSITORY_NWO: ${{ github.repository }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }} 
          fetch-depth: 0 # Fetch all history so branches can be managed properly

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install PyGithub requests google-generativeai # Add other necessary libraries
          sudo apt-get update && sudo apt-get install -y gh # GitHub CLI

      - name: Create Script Directory
        run: mkdir -p .github/scripts

      - name: Create AI Issue Processor Script (Conceptual)
        run: |
          cat << 'EOF' > .github/scripts/ai_issue_processor.py
          # Conceptual Python Script: .github/scripts/ai_issue_processor.py
          # This script needs to be fully developed.
          import os
          import sys
          import json
          import time
          from github import Github, GithubException
          import google.generativeai as genai
          import subprocess

          # --- Configuration ---
          GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
          GEMINI_MODEL_NAME = os.getenv('GEMINI_MODEL', 'gemini-2.5-pro-preview-05-06') # Default if not set
          GH_TOKEN = os.getenv('GH_TOKEN')
          REPO_NWO = os.getenv('GITHUB_REPOSITORY_NWO') # e.g., "owner/repo"
          TARGET_BRANCH = os.getenv('TARGET_BRANCH', 'main')
          GIT_COMMIT_USER_NAME = os.getenv('GIT_COMMIT_USER_NAME')
          GIT_COMMIT_USER_EMAIL = os.getenv('GIT_COMMIT_USER_EMAIL')
          
          ISSUE_NUMBER_INPUT = os.getenv('INPUT_ISSUE_NUMBER', '') # From workflow inputs
          MAX_ISSUES_TO_PROCESS = int(os.getenv('INPUT_MAX_ISSUES_TO_PROCESS', 1))
          ALLOW_PR_CREATION = os.getenv('INPUT_ALLOW_PR_CREATION', 'false').lower() == 'true'

          if not GEMINI_API_KEY:
              print("Error: GEMINI_API_KEY environment variable not set.")
              sys.exit(1)
          if not GH_TOKEN:
              print("Error: GH_TOKEN environment variable not set.")
              sys.exit(1)
          if not REPO_NWO:
              print("Error: GITHUB_REPOSITORY_NWO environment variable not set.")
              sys.exit(1)

          genai.configure(api_key=GEMINI_API_KEY)
          g = Github(GH_TOKEN)
          try:
              repo = g.get_repo(REPO_NWO)
          except GithubException as e:
              print(f"Error: Could not get repository '{REPO_NWO}'. Check token permissions and repository name. Details: {e}")
              sys.exit(1)

          # --- Helper Functions ---
          def get_issues_to_process():
              issues_to_process = []
              if ISSUE_NUMBER_INPUT:
                  try:
                      issue = repo.get_issue(number=int(ISSUE_NUMBER_INPUT))
                      if issue.state == 'open':
                          issues_to_process.append(issue)
                      else:
                          print(f"Issue #{ISSUE_NUMBER_INPUT} is not open. Skipping.")
                  except GithubException as e:
                      print(f"Error fetching issue #{ISSUE_NUMBER_INPUT}: {e}")
                  except ValueError:
                      print(f"Error: Invalid issue number provided: {ISSUE_NUMBER_INPUT}")
              else:
                  open_issues = repo.get_issues(state='open', sort='created', direction='asc')
                  count = 0
                  for issue in open_issues:
                      # Add filtering logic here (e.g., labels, no assignee, no "ai-in-progress" label)
                      if count < MAX_ISSUES_TO_PROCESS:
                          # Check if a PR from an AI branch already exists for this issue
                          branch_name = f"ai-fix/issue-{issue.number}"
                          try:
                              repo.get_branch(branch=branch_name)
                              print(f"Branch {branch_name} already exists for issue #{issue.number}. Skipping.")
                              # Potentially check for open PRs from this branch too
                              continue 
                          except GithubException: # Branch does not exist, good to proceed
                              pass
                          
                          issues_to_process.append(issue)
                          count += 1
                      else:
                          break
              return issues_to_process

          def get_relevant_code_context(issue_body, issue_title):
              # ADVANCED: This is a placeholder for a sophisticated function.
              # It would need to:
              # 1. Parse the issue for filenames, function names, error messages.
              # 2. Search the codebase for these references.
              # 3. Potentially use embeddings or other AI techniques to find semantically relevant code.
              # 4. Fetch the content of these files.
              # For now, it might just return a generic message or try to fetch a few common files.
              print(f"Fetching code context for issue: {issue_title}...")
              context = "Relevant code context needs to be implemented. Consider these files:\n"
              # Example: try to find files mentioned in the issue body
              # This is a very naive approach
              potential_files = []
              if issue_body: # Ensure issue_body is not None
                  for word in issue_body.split():
                      if '.cpp' in word or '.h' in word or '.py' in word or '.js' in word or '.yml' in word:
                           # Clean up potential punctuation
                           cleaned_word = ''.join(filter(lambda x: x.isalnum() or x in ['.', '/', '_', '-'], word))
                           if cleaned_word not in potential_files:
                               potential_files.append(cleaned_word)
              
              for f_path in potential_files:
                  try:
                      # Ensure f_path is relative to repo root and not absolute
                      if f_path.startswith('/'): f_path = f_path[1:]
                      file_content_obj = repo.get_contents(f_path)
                      file_content = file_content_obj.decoded_content.decode('utf-8')
                      context += f"File: {f_path}\n---\n{file_content[:2000]}\n---\n" # Limit context size
                      print(f"  Added context from: {f_path}")
                  except GithubException:
                      print(f"  Could not fetch file: {f_path}")
                      pass # File might not exist or path is incorrect
              if not potential_files:
                  context += "No specific files identified in issue body. General project context might be needed.\n"
              return context

          def call_gemini_api(prompt_text):
              print(f"Calling Gemini API (Model: {GEMINI_MODEL_NAME})...")
              try:
                  model = genai.GenerativeModel(GEMINI_MODEL_NAME)
                  # IMPORTANT: Review Gemini API documentation for correct request structure,
                  # safety settings, and generation config.
                  response = model.generate_content(
                      prompt_text,
                      generation_config=genai.types.GenerationConfig(
                          # candidate_count=1, # Default is 1
                          # max_output_tokens=8192, # Adjust as needed
                          temperature=0.3, # Lower for more deterministic code fixes
                      ),
                      # safety_settings=[...], # Configure safety settings
                  )
                  # Assuming the response has a 'text' attribute or similar for the generated content.
                  # This will vary based on the Gemini SDK version.
                  # Accessing parts of a Candidate, then text of a Part
                  if response.candidates and response.candidates[0].content and response.candidates[0].content.parts:
                      return response.candidates[0].content.parts[0].text
                  else:
                      print("Warning: Gemini API response structure not as expected or empty.")
                      print(f"Full response: {response}")
                      return None
              except Exception as e:
                  print(f"Error calling Gemini API: {e}")
                  return None

          def parse_and_apply_changes(ai_response_text, current_branch_name):
              # EXTREMELY COMPLEX: This function needs to:
              # 1. Reliably parse the AI's response to identify filenames and new code content.
              #    The AI must be prompted to provide output in a very specific, machine-parsable format.
              #    Example format to ask for:
              #    FILENAME: path/to/your/file.ext
              #    ```[language_extension_optional]
              #    // new content for file.ext
              #    ```
              #    FILENAME: path/to/another/file.h
              #    ```[language_extension_optional]
              #    // new content for file.h
              #    ```
              # 2. For each identified file:
              #    a. Create directories if they don't exist.
              #    b. Write the new content to the file, overwriting the old one.
              #    c. OR, if the AI provides diffs/patches, apply them using `git apply`.
              # 3. Return True if changes were successfully applied, False otherwise.
              print("Parsing AI response and attempting to apply changes...")
              applied_changes = False
              try:
                  # This is a conceptual parsing logic. You'll need robust parsing.
                  if not ai_response_text:
                      print("  AI response is empty. No changes to apply.")
                      return False

                  # For demonstration, let's assume a simple single file change to README.md
                  # In a real scenario, this would parse multiple files and their contents.
                  if "README.md" in ai_response_text and "```" in ai_response_text: # Very basic check
                      new_content_parts = ai_response_text.split("```")
                      if len(new_content_parts) > 1:
                          code_block_content = new_content_parts[1]
                          if '\n' in code_block_content:
                              first_line, rest_of_code = code_block_content.split('\n', 1)
                              if first_line.strip().isalnum() and len(first_line.strip()) < 10: # Likely a language specifier
                                  actual_code = rest_of_code
                              else:
                                  actual_code = code_block_content
                          else: 
                              actual_code = code_block_content

                          with open("README.md", "a") as f: # Append for demo, real would overwrite
                              f.write("\n# AI Suggested Change (Branch: " + current_branch_name + ")\n")
                              f.write(actual_code.strip())
                          print("  Applied dummy change to README.md")
                          applied_changes = True
                      else:
                          print("  Could not parse code block from AI response for README.md.")
                  else:
                      print("  AI response did not contain expected format for README.md or any changes.")

              except Exception as e:
                  print(f"Error applying changes: {e}")
                  return False
              
              if not applied_changes:
                  print("No changes were applied based on AI response.")
              return applied_changes

          def run_git_command(command_list):
              try:
                  print(f"Running git command: {' '.join(command_list)}")
                  result = subprocess.run(command_list, check=True, capture_output=True, text=True)
                  print(f"STDOUT: {result.stdout}")
                  if result.stderr:
                      print(f"STDERR: {result.stderr}")
                  return True
              except subprocess.CalledProcessError as e:
                  print(f"Git command failed: {' '.join(command_list)}")
                  print(f"Return code: {e.returncode}")
                  print(f"STDOUT: {e.stdout}")
                  print(f"STDERR: {e.stderr}")
                  return False

          # --- Main Processing Logic ---
          def main():
              print(f"Starting AI Issue Resolver for repository: {REPO_NWO}")
              print(f"Target branch for PRs: {TARGET_BRANCH}")
              print(f"Allow PR Creation: {ALLOW_PR_CREATION}")

              issues = get_issues_to_process()
              if not issues:
                  print("No open issues found to process based on criteria.")
                  return

              for issue in issues:
                  print(f"\nProcessing Issue #{issue.number}: {issue.title}")
                  
                  branch_name = f"ai-fix/issue-{issue.number}"
                  
                  # Ensure we are on the target branch before creating a new one from it
                  run_git_command(["git", "checkout", TARGET_BRANCH])
                  run_git_command(["git", "pull", "origin", TARGET_BRANCH]) # Ensure target branch is up-to-date

                  # Delete local branch if it exists from a previous failed run
                  run_git_command(["git", "branch", "-D", branch_name]) # Ignores error if branch doesn't exist
                  
                  # Create and checkout new branch
                  if not run_git_command(["git", "checkout", "-b", branch_name, f"origin/{TARGET_BRANCH}"]):
                      print(f"Failed to create or checkout branch {branch_name}. Skipping issue.")
                      continue 

                  code_context = get_relevant_code_context(issue.body if issue.body else "", issue.title)
                  
                  prompt = (
                      f"You are an expert software developer tasked with fixing a GitHub issue.\n"
                      f"Repository: {REPO_NWO}\n"
                      f"Issue Number: #{issue.number}\n"
                      f"Issue Title: {issue.title}\n"
                      f"Issue Description:\n{issue.body if issue.body else 'No description provided.'}\n\n"
                      f"Relevant Code Context (if any was found):\n{code_context}\n\n"
                      f"Your task is to provide the necessary code changes to resolve this issue.\n"
                      f"Please output the complete new content for each file that needs to be modified.\n"
                      f"Format your response strictly as follows for each file:\n"
                      f"FILENAME: path/to/your/file.ext\n"
                      f"```[language_extension_optional]\n"
                      f"// New, complete content for the file\n"
                      f"```\n"
                      f"If no code changes are needed, or if you cannot resolve the issue, please state that clearly.\n"
                      f"Focus on providing only the modified file contents in the specified format."
                  )
                  
                  ai_response = call_gemini_api(prompt)
                  
                  if ai_response:
                      print(f"AI Response for issue #{issue.number} (first 500 chars):\n{ai_response[:500]}...") 
                      if parse_and_apply_changes(ai_response, branch_name):
                          print(f"Code changes applied for issue #{issue.number}.")
                          if not run_git_command(["git", "add", "."]):
                              print(f"Failed to git add changes for issue #{issue.number}. Skipping PR creation.")
                              run_git_command(["git", "checkout", TARGET_BRANCH]) 
                              run_git_command(["git", "branch", "-D", branch_name]) 
                              continue

                          commit_message = f"AI fix for issue #{issue.number}: {issue.title}"
                          if not run_git_command(["git", "commit", "-m", commit_message]):
                              print(f"Failed to git commit changes for issue #{issue.number}. Skipping PR creation.")
                              run_git_command(["git", "checkout", TARGET_BRANCH]) 
                              run_git_command(["git", "branch", "-D", branch_name])
                              continue

                          if not run_git_command(["git", "push", "-u", "origin", branch_name, "--force"]): # Added --force for retries
                              print(f"Failed to git push branch {branch_name} for issue #{issue.number}. Skipping PR creation.")
                              run_git_command(["git", "checkout", TARGET_BRANCH])
                              continue
                              
                          if ALLOW_PR_CREATION:
                              pr_title = f"AI Fix for Issue #{issue.number}: {issue.title}"
                              pr_body = (
                                  f"This PR was automatically generated by an AI assistant to address issue #{issue.number}.\n"
                                  f"Please review the changes carefully.\n\n"
                                  f"**Issue Details:**\nTitle: {issue.title}\n"
                                  f"Link: {issue.html_url}\n\n"
                                  f"**AI Suggestion Summary (first 500 chars):**\n```\n{ai_response[:500]}...\n```"
                              )
                              pr_command = [
                                  "gh", "pr", "create",
                                  "--base", TARGET_BRANCH,
                                  "--head", branch_name,
                                  "--title", pr_title,
                                  "--body", pr_body
                              ]
                              try:
                                  print(f"Creating PR for branch {branch_name}...")
                                  # Use subprocess.run for gh commands
                                  pr_result = subprocess.run(pr_command, check=True, capture_output=True, text=True)
                                  print(f"Successfully created PR for issue #{issue.number}: {pr_result.stdout}")
                              except subprocess.CalledProcessError as e:
                                  print(f"Failed to create PR for issue #{issue.number}: {e.stderr}")
                          else:
                              print(f"PR creation is disabled. Branch {branch_name} pushed for issue #{issue.number}. Manual PR needed.")
                      else:
                          print(f"No changes applied or error during application for issue #{issue.number}.")
                  else:
                      print(f"No response or error from AI for issue #{issue.number}.")
                  
                  print(f"Cleaning up after processing issue #{issue.number}...")
                  run_git_command(["git", "checkout", TARGET_BRANCH])
                  
                  if MAX_ISSUES_TO_PROCESS > 1 and issues.index(issue) < len(issues) - 1 :
                      print("Waiting for 60 seconds before processing next issue to avoid rate limits...")
                      time.sleep(60)

              print("AI Issue Resolver run finished.")

          if __name__ == "__main__":
              run_git_command(["git", "config", "--global", "user.name", GIT_COMMIT_USER_NAME])
              run_git_command(["git", "config", "--global", "user.email", GIT_COMMIT_USER_EMAIL])
              main()
          EOF
          chmod +x .github/scripts/ai_issue_processor.py

      - name: Run AI Issue Processor Script
        env: 
          INPUT_ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
          INPUT_MAX_ISSUES_TO_PROCESS: ${{ github.event.inputs.max_issues_to_process }}
          INPUT_ALLOW_PR_CREATION: ${{ github.event.inputs.allow_pr_creation }}
        run: python .github/scripts/ai_issue_processor.py # Explicitly use python
