# .github/workflows/ai_code_analysis.yml
name: AI Code Analysis & Issue Creation

on:
  workflow_dispatch: # Allows manual triggering
    inputs:
      branch:
        description: 'Branch to analyze'
        required: true
        default: 'main'

permissions:
  contents: read    # To checkout the repository
  issues: write     # To create GitHub issues

jobs:
  analyze_and_create_issues:
    runs-on: ubuntu-latest
    env:
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: pip install requests

      - name: Analyze Code and Create Issues
        run: |
          import os
          import json
          import requests
          import time

          GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
          if not GEMINI_API_KEY:
              print("::error::GEMINI_API_KEY secret not found.")
              exit(1)

          GITHUB_TOKEN = os.getenv('GITHUB_TOKEN') # Provided by GitHub Actions
          REPO_NAME = os.getenv('GITHUB_REPOSITORY') # e.g., owner/repo
          GEMINI_MODEL_NAME = "gemini-1.5-flash-latest" # Or "gemini-1.5-pro-latest"
          
          # --- Configuration for file discovery ---
          # Directories to scan for source files
          scan_directories = ["src", "test"] 
          # File extensions to consider for analysis
          target_extensions = (".cpp", ".h", ".hpp", ".c", ".cc") 
          # Directories to exclude from scanning (relative to repo root)
          excluded_dirs = [".pio", "data", "docs", ".git", ".github"] 
          # Specific files to exclude (full path relative to repo root or just filename)
          excluded_files = ["script.js", "style.css", "index.html"] # Add more if needed

          files_to_analyze = []
          repo_root = os.getcwd()

          for directory in scan_directories:
              scan_path = os.path.join(repo_root, directory)
              if not os.path.exists(scan_path):
                  print(f"::warning::Directory to scan not found: {scan_path}")
                  continue
              for root, dirs, files in os.walk(scan_path):
                  # Filter out excluded directories
                  dirs[:] = [d for d in dirs if os.path.join(root, d) not in [os.path.join(repo_root, ed) for ed in excluded_dirs] and d not in excluded_dirs]
                  
                  for file in files:
                      file_path_abs = os.path.join(root, file)
                      file_path_rel = os.path.relpath(file_path_abs, repo_root)
                      
                      if file.endswith(target_extensions) and file not in excluded_files and file_path_rel not in excluded_files:
                          # Further check if the file is within an excluded directory path string
                          is_excluded = False
                          for excluded_dir_path_str in excluded_dirs:
                              if file_path_rel.startswith(excluded_dir_path_str + os.sep):
                                  is_excluded = True
                                  break
                          if not is_excluded:
                              files_to_analyze.append(file_path_rel)
          
          if not files_to_analyze:
              print("::warning::No files found to analyze based on the criteria.")
              exit(0)
          
          print("Files selected for analysis:")
          for f_path in files_to_analyze:
              print(f"- {f_path}")


          # JSON schema expected from Gemini
          expected_schema = {
              "type": "OBJECT",
              "properties": {
                  "suggestions": {
                      "type": "ARRAY",
                      "items": {
                          "type": "OBJECT",
                          "properties": {
                              "type": { "type": "STRING", "enum": ["bug_fix", "feature_suggestion", "improvement"] },
                              "title": { "type": "STRING" },
                              "description": { "type": "STRING" },
                              "file_path": { "type": "STRING" },
                              "severity": { "type": "STRING", "enum": ["low", "medium", "high", "enhancement"], "optional": True }
                          },
                          "required": ["type", "title", "description", "file_path"]
                      }
                  }
              },
              "required": ["suggestions"]
          }

          def call_gemini_api(file_content, file_path):
              print(f"::group::Analyzing {file_path} with Gemini")
              api_url = f"https://generativelanguage.googleapis.com/v1beta/models/{GEMINI_MODEL_NAME}:generateContent?key={GEMINI_API_KEY}"
              
              prompt = f"""
              You are an expert C++/ESP32 code reviewer. Analyze the following C++ code from the file `{file_path}`.
              The project is an ESP32-based fan controller.
              Identify potential bugs with suggested fixes, propose new features, or suggest general code improvements.
              For each suggestion, provide a type ('bug_fix', 'feature_suggestion', or 'improvement'), a concise title for a GitHub issue,
              a detailed description (use Markdown for formatting if helpful), the file_path it pertains to, and an optional severity ('low', 'medium', 'high' for bugs, 'enhancement' for features/improvements).

              Respond ONLY with a JSON object matching the following schema. Do not include any other text before or after the JSON object:
              ```json
              {json.dumps(expected_schema, indent=2)}
              ```

              Code to analyze:
              ```cpp
              {file_content}
              ```
              """

              payload = {
                  "contents": [{"role": "user", "parts": [{"text": prompt}]}],
                  "generationConfig": {
                      "responseMimeType": "application/json",
                      "temperature": 0.3, 
                      "topP": 0.9,
                      "topK": 40
                  }
              }
              
              headers = {'Content-Type': 'application/json'}
              
              max_retries = 3
              for attempt in range(max_retries):
                  try:
                      response = requests.post(api_url, headers=headers, json=payload, timeout=180) 
                      response.raise_for_status() 
                      
                      try:
                          result_json = response.json()
                          if "candidates" in result_json and result_json["candidates"] and \
                             "content" in result_json["candidates"][0] and \
                             "parts" in result_json["candidates"][0]["content"] and \
                             result_json["candidates"][0]["content"]["parts"]:
                              
                              raw_text_response = result_json["candidates"][0]["content"]["parts"][0].get("text", "")
                              try:
                                  parsed_suggestions = json.loads(raw_text_response)
                                  if "suggestions" in parsed_suggestions:
                                      print(f"Successfully parsed suggestions for {file_path}")
                                      print("::endgroup::")
                                      return parsed_suggestions["suggestions"]
                                  else:
                                      print(f"::warning::Gemini response for {file_path} did not contain 'suggestions' key in the parsed text part.")
                                      print(f"Raw text response: {raw_text_response}")

                              except json.JSONDecodeError as je:
                                  print(f"::error::Failed to decode JSON from Gemini's text response for {file_path}: {je}")
                                  print(f"Gemini raw text response: {raw_text_response}")
                          else:
                              print(f"::warning::Gemini response structure for {file_path} was not as expected.")
                              print(f"Full Gemini response: {result_json}")

                      except json.JSONDecodeError as e:
                          print(f"::error::Failed to decode JSON from Gemini response for {file_path}: {e}")
                          print(f"Gemini raw response content: {response.text}")
                      
                      break 
                  except requests.exceptions.RequestException as e:
                      print(f"::warning::Error calling Gemini API for {file_path} (attempt {attempt + 1}/{max_retries}): {e}")
                      if attempt < max_retries - 1:
                          time.sleep(5 * (attempt + 1)) 
                      else:
                          print(f"::error::Failed to get suggestions for {file_path} after {max_retries} attempts.")
              
              print("::endgroup::")
              return []


          def create_github_issue(title, body, file_path, suggestion_type, severity=None):
              print(f"::group::Creating issue for: {title}")
              url = f"https://api.github.com/repos/{REPO_NAME}/issues"
              headers = {
                  "Authorization": f"token {GITHUB_TOKEN}",
                  "Accept": "application/vnd.github.v3+json"
              }
              
              labels = ["AI Generated", suggestion_type.replace("_", "-")]
              if severity:
                  labels.append(f"severity-{severity}")
              if "feature" in suggestion_type or "improvement" in suggestion_type:
                  labels.append("enhancement")
              elif "bug" in suggestion_type:
                  labels.append("bug")


              issue_body = f"**File:** `{file_path}`\n\n"
              issue_body += f"**Suggestion Type:** {suggestion_type.replace('_', ' ').title()}\n"
              if severity:
                  issue_body += f"**AI Severity/Priority:** {severity.title()}\n\n"
              issue_body += "---\n\n"
              issue_body += f"{body}\n\n"
              issue_body += "---\n\n"
              issue_body += "_This issue was automatically generated by an AI code analysis workflow._"

              data = {
                  "title": f"[AI Suggestion] {title}",
                  "body": issue_body,
                  "labels": labels
              }
              
              response = requests.post(url, headers=headers, json=data)
              if response.status_code == 201:
                  print(f"Successfully created issue: {response.json()['html_url']}")
              else:
                  print(f"::error::Failed to create GitHub issue for '{title}'. Status: {response.status_code}, Response: {response.text}")
              print("::endgroup::")


          for file_path_rel in files_to_analyze: # Iterate over relative paths
              absolute_file_path = os.path.join(repo_root, file_path_rel)
              if not os.path.exists(absolute_file_path): # Should not happen if discovery was correct
                  print(f"::warning::File not found during processing: {absolute_file_path}. Skipping.")
                  continue

              print(f"Processing file: {file_path_rel}")
              try:
                  with open(absolute_file_path, 'r', encoding='utf-8') as f:
                      content = f.read()
              except Exception as e:
                  print(f"::error::Could not read file {file_path_rel}: {e}")
                  continue
              
              if not content.strip():
                  print(f"::warning::File {file_path_rel} is empty. Skipping.")
                  continue

              suggestions = call_gemini_api(content, file_path_rel) # Pass relative path to Gemini
              
              if suggestions:
                  for suggestion in suggestions:
                      s_type = suggestion.get('type', 'improvement')
                      s_title = suggestion.get('title', f"AI Suggestion for {file_path_rel}")
                      s_description = suggestion.get('description', "No description provided by AI.")
                      # Ensure AI uses the relative path it was given, or fall back
                      s_file_path_from_ai = suggestion.get('file_path', file_path_rel) 
                      s_severity = suggestion.get('severity')
                      
                      if "AI Suggestion for" in s_title and len(s_description) > 50:
                          s_title = f"[AI] {s_type.replace('_', ' ').title()}: {s_description[:50].strip()}..."

                      create_github_issue(s_title, s_description, s_file_path_from_ai, s_type, s_severity)
                      time.sleep(2) 
              else:
                  print(f"No suggestions returned by AI for {file_path_rel}.")

          print("AI code analysis and issue creation process complete.")
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 
